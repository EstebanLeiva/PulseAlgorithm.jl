var documenterSearchIndex = {"docs":
[{"location":"#PulseAlgorithm.jl","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"","category":"page"},{"location":"#Introduction","page":"PulseAlgorithm.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PulseAlgorithm.jl provides an implementation for the Pulse Algorithm for Reliable Shortest Path Problems (PA-RSPPs) designed to tackle challenging stochastic shortest path problems in networks with normally distributed link travel times with correlation. This algorithm scales efficiently in large networks and performs competitively with state-of-the-art methods. This package is designed for researchers and practitioners in transportation engineering, logistics, and telecommunications in which these types of networks may arise. ","category":"page"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"The package is available under MIT License. ","category":"page"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PulseAlgorithm documentation is organized in two sections:","category":"page"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"Graph Structure: documentation for the graph data structure used.\nData Loading: documentation for the data loader for real transportation networks found in Transportation Networks\nUtil: documentation for utility functions.\nPulse Algorithm for Reliable Shortest Path Problems (PA-RSPPs): documentation for the PA-RSPPs algorithm applied to different settings.","category":"page"},{"location":"#Installation","page":"PulseAlgorithm.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"To install PulseAlgorithm.jl, you can use the Julia package manager. Open the Julia REPL and run the following command:","category":"page"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"pkg> add https://github.com/EstebanLeiva/PulseAlgorithm.jl","category":"page"},{"location":"#Graph","page":"PulseAlgorithm.jl","title":"Graph","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PA.Link\nPA.Node\nPA.Graph\nPA.create_node!\nPA.find\nPA.find_or_add!\nPA.add_link!\nPA.get_links_info","category":"page"},{"location":"#PulseAlgorithm.Link","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.Link","text":"Link(cost::Float64, mean::Float64, variance::Float64, value::Float64)\n\nSimple link structure.\n\nParameters\n\ncost::Float64: Link cost.\nmean::Float64: Link travel time mean.\nvariance::Float64: Link travel time variance.\nvalue::Float64: Link value.\n\n\n\n\n\n","category":"type"},{"location":"#PulseAlgorithm.Node","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.Node","text":"Node(name::String, links::Dict{Int, Link}, incoming_links::Dict{Int, Link})\n\nSimple node structure.\n\nThe links dictionary stores the outgoing links where the key is the destination node index and the value is the link itself. The incoming_links dictionary stores the incoming links where the key is the source node index and the value is the link itself.\n\n\n\n\n\n","category":"type"},{"location":"#PulseAlgorithm.Graph","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.Graph","text":"Graph(nodes::Dict{Int, Node}, name_to_index::Dict{String, Int})\n\nSimple graph structure. \n\nThe nodes are stored in a dictionary where the key is the node index and the value is the node itself.  The nametoindex dictionary is used to map the node name to the node index.\n\n\n\n\n\n","category":"type"},{"location":"#PulseAlgorithm.create_node!","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.create_node!","text":"create_node!(graph::Graph, name::String)\n\nCreate a new node in the graph.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.find","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.find","text":"find(graph::Graph, name::String)\n\nFind the node index given the node name.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.find_or_add!","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.find_or_add!","text":"find_or_add!(graph::Graph, name::String)\n\nFind the node index given the node name. If the node does not exist, create a new node.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.add_link!","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.add_link!","text":"add_link!(graph::Graph, src_name::String, dst_name::String, cost::Float64, mean::Float64, variance::Float64)\n\nAdd a link between two nodes.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.get_links_info","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.get_links_info","text":"get_links_info(graph::Graph)\n\nReturn a dictionary with the link information.\n\n\n\n\n\n","category":"function"},{"location":"#Dijkstra","page":"PulseAlgorithm.jl","title":"Dijkstra","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PA.dijkstra\nPA.dijkstra_between_nodes","category":"page"},{"location":"#PulseAlgorithm.dijkstra","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.dijkstra","text":"dijkstra(graph::Graph, target_node::Int, path::String)\n\nReturn a vector with the cost to reach the target node from all other nodes in the graph.\n\nPriority Queue implementation of Dijkstra's algorithm.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.dijkstra_between_nodes","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.dijkstra_between_nodes","text":"dijkstra_between_nodes(graph::Graph, start_node::Int, target_node::Int, type::String)\n\nReturn the shortest path between two nodes in the graph.\n\nPriority Queue implementation of Dijkstra's algorithm between two nodes.\n\n\n\n\n\n","category":"function"},{"location":"#Data-Loader","page":"PulseAlgorithm.jl","title":"Data Loader","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PA.TAData\nPA.load_ta\nPA.load_flowCost\nPA.calculate_fft_coefficient\nPA.load_graph_from_ta","category":"page"},{"location":"#PulseAlgorithm.TAData","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.TAData","text":"TAData(network_name::String, number_of_zones::Int, number_of_nodes::Int, first_thru_node::Int, number_of_links::Int, start_node::Array{Int,1}, end_node::Array{Int,1}, capacity::Array{Float64,1}, link_length::Array{Float64,1}, free_flow_time::Array{Float64,1}, B::Array{Float64,1}, power::Array{Float64,1}, speed_limit::Array{Float64,1}, toll::Array{Float64,1}, link_type::Array{Int64,1})\n\nSimple structure to store the traffic assignment data.\n\n\n\n\n\n","category":"type"},{"location":"#PulseAlgorithm.load_ta","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.load_ta","text":"load_ta(network_data_file::String, network_name::String)\n\nLoad the traffic assignment network data.\n\nSee also load_graph_from_ta.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.load_flowCost","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.load_flowCost","text":"load_flowCost(flow_file_dir:: String)\n\nLoad the flow cost data.\n\nSee also load_graph_from_ta.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.calculate_fft_coefficient","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.calculate_fft_coefficient","text":"calculate_fft_coefficient(ta_data::TAData)\n\nCalculate the average freeflowtime/link_length coefficient.\n\nThis is used to replace zero entries in the freeflowtime field.\n\nSee also load_graph_from_ta.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.load_graph_from_ta","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.load_graph_from_ta","text":"load_graph_from_ta(tntp_file_dir::String, flow_file_dir:: String, network_name::String, CV::Float64, toll_factor::Float64, length_factor::Float64)\n\nLoad a graph with the traffic assignment data.\n\nThe cost, mean, and variance are calculated as explained in the Transportation Networks repository.\n\nSee also load_ta, load_flowCost, calculate_fft_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"#Util","page":"PulseAlgorithm.jl","title":"Util","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PA.get_path_distribution\nPA.modified_dfs\nPA.get_covariance_dict\nPA.get_higher_priority_paths\nPA.get_covariance_term","category":"page"},{"location":"#PulseAlgorithm.get_path_distribution","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.get_path_distribution","text":"get_path_distribution(graph::Graph, path::Vector{Int}, cov_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64})\n\nReturn the mean, variance and covariance term of a given path's travel time distribution.\n\nSee also get_covariance_term.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.modified_dfs","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.modified_dfs","text":"modified_dfs(graph::Graph, start_link::Tuple{Int, Int}, max_depth::Int, depth::Int, visited_pairlinks::Dict{Tuple{Int, Int}, Int}, previous_node::Int)\n\nReturn the links at a distance less or equal to max_depth from the starting link.\n\nSee also get_covariance_dict.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.get_covariance_dict","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.get_covariance_dict","text":"get_covariance_dict(graph::Graph, ρ::Float64, max_depth::Int)\n\nReturn the covariance dictionary of a graph following a spatial correlation structure of radius=max_depth.\n\nSee also modified_dfs.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.get_higher_priority_paths","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.get_higher_priority_paths","text":"get_higher_priority_paths(pq::PriorityQueue, element::Vector{Int})\n\nReturn the elements with higher priority than the given element in a priority queue.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.get_covariance_term","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.get_covariance_term","text":"get_covariance_term(covariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}, reachable_node::Int, path::Vector{Int})\n\nReturn the covariance term of the given path's travel time distribution.\n\nSee also get_path_distribution, pulse.\n\n\n\n\n\n","category":"function"},{"location":"#PA-S-\\alphaRP","page":"PulseAlgorithm.jl","title":"PA-S-alphaRP","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PA.PaSarp\nPA.initialize_PaSarp\nPA.preprocess!(::PaSarp)\nPA.check_feasibility(::PaSarp, ::Int, ::Float64, ::Float64, ::Float64, ::Vector{Int})\nPA.check_bounds(::PaSarp, ::Int, ::Float64, ::Vector{Int})\nPA.pulse(::PaSarp, ::Int, ::Float64, ::Float64, ::Float64, ::Float64, ::Vector{Int})\nPA.run_pulse(::PaSarp, ::Vector{Int}, B::Float64)","category":"page"},{"location":"#PulseAlgorithm.PaSarp","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.PaSarp","text":"PaSarp(G::Graph, α::Float64, covariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}, minimum_costs::Vector{Float64}, variance_costs::Vector{Float64}, mean_costs::Vector{Float64}, optimal_path::Vector{Int}, B::Float64, T_max::Float64, source_node::Int, target_node::Int, instance_info::Dict{String, Any})\n\nDefine the struct that will contain the information of the PA-S-αRP algorithm.\n\nParameters\n\nG::Graph: Graph.\nα::Float64: Reliability constraint.\ncovariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}: Covariance information.\nminimum_costs::Vector{Float64}: Minimum cost to reach the target node.\nvariance_costs::Vector{Float64}: Minimum variance to reach the target node.\nmean_costs::Vector{Float64}: Minimum mean to reach the target node.\noptimal_path::Vector{Int}: Optimal path.\nB::Float64: Best cost found so far (corresponds to the cost of the optimal path).\nT_max::Float64: Travel time budget.\nsource_node::Int: Source node.\ntarget_node::Int: Target node.\ninstance_info::Dict{String, Any}: Instance information.\n\n\n\n\n\n","category":"type"},{"location":"#PulseAlgorithm.initialize_PaSarp","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.initialize_PaSarp","text":"initialize_PaSarp(G::Graph, α::Float64, covariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}, source_node::String, target_node::String, T_max::Float64)\n\nInitialize the PaSarp struct.\n\nArguments\n\nG::Graph: Graph.\nα::Float64: Reliability constraint.\ncovariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}: Covariance information.\nsource_node::String: Source node.\ntarget_node::String: Target node.\nT_max::Float64: Travel time budget.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.preprocess!-Tuple{PaSarp}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.preprocess!","text":"preprocess!(pa::PaSarp)\n\nCalculate the minimum costs, variance costs, and mean costs to reach the target node;  while ensuring that there is a path between the source and target nodes.\n\nNote that this information could be saved into a file if the graph is static and could be reused in future runs.\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.check_feasibility-Tuple{PaSarp, Int64, Float64, Float64, Float64, Vector{Int64}}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.check_feasibility","text":"check_feasibility(pa::PaSarp, current_node::Int, mean_path::Float64, variance_path::Float64, covariance_term_path::Float64, path::Vector{Int})\n\nCheck if the path is feasible with respect to the time budget and the reliability constraint. \n\nReturn true if the path is feasible; and false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.check_bounds-Tuple{PaSarp, Int64, Float64, Vector{Int64}}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.check_bounds","text":"check_bounds(pa::PaSarp, current_node::Int, cost::Float64, path::Vector{Int})\n\nCheck if the partial path can improve the current solution. \n\nReturn true if it can improve the current solution; and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.pulse-Tuple{PaSarp, Int64, Float64, Float64, Float64, Float64, Vector{Int64}}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.pulse","text":"pulse(pa::PaSarp, current_node::Int, cost::Float64, mean_path::Float64, variance_path::Float64, covariance_term_path::Float64, path::Vector{Int})\n\nPropagate the pulses through the graph while checking the pruning criteria.\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.run_pulse-Tuple{PaSarp, Vector{Int64}, Float64}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.run_pulse","text":"run_pulse(pa::PaSarp, optimal_path::Vector{Int}, B::Float64)\n\nRun the PA-S-αRP algorithm. Using an initial optimal path and cost is optional  and it can be used to improve the performance of the algorithm.\n\nArguments\n\npa::PaSarp: PaSarp struct.\noptimal_path::Vector{Int}=Vector{Int}(): Initial path.\nB::Float64=Inf: Cost of the initial  path.\n\n\n\n\n\n","category":"method"},{"location":"#PA-SD_RSPP","page":"PulseAlgorithm.jl","title":"PA-SD_RSPP","text":"","category":"section"},{"location":"","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.jl","text":"PA.PaSdrspp\nPA.initialize_PaSdrspp\nPA.preprocess!(::PaSdrspp)\nPA.check_bounds(::PaSdrspp, ::Int, ::Float64, ::Float64, ::Float64, ::Vector{Int})\nPA.pulse(::PaSdrspp, ::Int, ::Float64, ::Float64, ::Float64, ::Vector{Int}, ::Int)\nPA.run_pulse(::PaSdrspp, ::Vector{Int}, B::Float64)","category":"page"},{"location":"#PulseAlgorithm.PaSdrspp","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.PaSdrspp","text":"PaSdrspp\n\nA struct to store the information of the PaSdrspp algorithm.\n\nParameters\n\nG::Graph: Graph.\nα::Float64: Input reliability.\ncovariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}: Covariance information.\nvariance_costs::Vector{Float64}: Minimum variance to reach the target node.\nmean_costs::Vector{Float64}: Minimum mean to reach the target node.\noptimal_path::Vector{Int}: Optimal path.\nB::Float64: Best quantile found so far (corresponds to the α-quantile of the optimal path).\nsource_node::Int: Source node.\ntarget_node::Int: Target node.\n\n\n\n\n\n","category":"type"},{"location":"#PulseAlgorithm.initialize_PaSdrspp","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.initialize_PaSdrspp","text":"initialize_PaSdrspp(G::Graph, α::Float64, covariance_dict::DefaultDict{Tuple{Int, Int, Int, Int}, Float64}, source_node::String, target_node::String, max_pulse_depth::Int)\n\nInitialize the PaSdrspp struct with a pulse queue with length of exploration maxpulsedepth.\n\n\n\n\n\n","category":"function"},{"location":"#PulseAlgorithm.preprocess!-Tuple{PaSdrspp}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.preprocess!","text":"preprocess!(sdp::PaSdrspp)\n\nPreprocess the graph to calculate the minimum mean and variance to reach the target node.\n\nNote that this information could be saved into a file if the graph is static and could be reused in future runs.\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.check_bounds-Tuple{PaSdrspp, Int64, Float64, Float64, Float64, Vector{Int64}}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.check_bounds","text":"check_bounds(sdp::PaSdrspp, current_node::Int, mean_path::Float64, variance_path::Float64, covariance_term_path::Float64, path::Vector{Int})\n\nCheck if the partial path can improve the current solution. \n\nReturn true if it can improve the current solution; and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.pulse-Tuple{PaSdrspp, Int64, Float64, Float64, Float64, Vector{Int64}, Int64}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.pulse","text":"pulse(sdp::PaSdrspp, current_node::Int, cost::Float64, mean_path::Float64, variance_path::Float64, covariance_term_path::Float64, path::Vector{Int}, pulse_depth::Int)\n\nPropagate the pulses through the graph while checking the pruning criteria and maintaining the pulse queue.\n\n\n\n\n\n","category":"method"},{"location":"#PulseAlgorithm.run_pulse-Tuple{PaSdrspp, Vector{Int64}, Float64}","page":"PulseAlgorithm.jl","title":"PulseAlgorithm.run_pulse","text":"run_pulse(sdp::PaSdrspp, optimal_path = Vector{Int}(), B = Inf)\n\nRun the PA-SD-RSPP algorithm. Using an initial path and quantile is optional  and it can be used to improve the performance of the algorithm.\n\nArguments\n\nsdp::PaSdrspp: PaSdrspp struct.\noptimal_path::Vector{Int}: Initial path.\nB::Float64: Best quantile found so far (corresponds to the α-quantile of the initial path).\n\n\n\n\n\n","category":"method"}]
}
